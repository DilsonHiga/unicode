## The purpose of this file is to generate the InternalEAW.roc file.
##
## This file will read the test data from `data/EastAsianWidth-15.1.0.txt`
## parse it and then generate function to test the East Asian Width property of a code point.
app [main] {
    pf: platform "https://github.com/roc-lang/basic-cli/releases/download/0.10.0/vNe6s9hWzoTZtFmNkvEICPErI9ptji_ySjicO6CkucY.tar.br",
}

import pf.Stdout
import pf.File
import pf.Path
import pf.Task
import pf.Arg
import pf.Stderr
import "data/EastAsianWidth-15.1.0.txt" as file : Str
import Helpers

hexToU32 = \hex ->
    hex
    |> Str.toU32
    |> Result.withDefault 0

main =
    strToPath = \arg -> Path.fromStr "$(Helpers.removeTrailingSlash arg)/InternalEAW.roc"
    Task.await Arg.list \args ->
        pathRes =
            args
            |> List.get 1
            |> Result.map strToPath
        when pathRes is
            Ok path -> writeToFile path
            Err _ -> Stderr.line "USAGE: roc run InternalEAW.roc -- path/to/package/"

writeToFile = \path ->
    File.writeUtf8 path template
    |> Task.attempt \result ->
        when result is
            Ok _ -> Stdout.line "\nSuccessfully wrote to $(Path.display path)\n"
            Err _ -> Stderr.line "ERROR: unable to write to $(Path.display path)"

template =
    """
    ## WARNING This file is automatically generated. Do not edit it manually. ##
    module [eastAsianWidthProperty, eastAsianWidth]

    eastAsianWidth = \\codePoint ->
        when eastAsianWidthProperty codePoint is
            F | W | A -> 2
            H | N | Na -> 1

    eastAsianWidthProperty = \\cp -> $(testsStr)
    """

# The ranges are specified as its starting point and an optional inclusive end point
# if it's length is greater than 1. The range is followed by the East_Asian_Width property
# separated by a semicolon.
# Examples:
# 0000..001F     ; N    # The property may be followed by comments
# 0020           ; Na
parseLine = \line ->
    listToParsingState = \rest -> { val: [], rest }

    startHexBytes = line |> Str.toUtf8 |> listToParsingState |> Helpers.takeHexBytes
    endHexBytes =
        when startHexBytes.rest is
            ['.', '.', .. as rest] -> rest |> listToParsingState |> Helpers.takeHexBytes
            _ -> startHexBytes # This range has length 1. The start will be repeated as the end
    endHexBytes.rest
    |> List.splitFirst ';'
    |> Result.map \{ after } -> after
    |> Result.try \commentdEAP -> List.splitFirst commentdEAP '#'
    |> Result.map \{ before } -> before
    |> Result.try Str.fromUtf8
    |> Result.map Str.trim
    |> Result.try \eawp ->
        startHexBytes.val
        |> Str.fromUtf8
        |> Result.map \start -> (eawp, "0x$(start)")
    |> Result.try \(eawp, start) ->
        endHexBytes.val
        |> Str.fromUtf8
        |> Result.map \end -> (eawp, start, "0x$(end)")

parsedLines = file |> Str.split "\n" |> List.map parseLine

originalRanges =
    parsedLines
    |> List.keepOks \x -> x

# We can drop the Neutral ranges because those are the default
optimizedRanges =
    List.dropIf originalRanges \(eawp, _, _) -> eawp == "N"

# The input file contains many consecutive ranges with the same property value.
# We will merge them into wider ranges to work with a smaller number of ranges.
mergedRanges =
    op = \state, currentValue ->
        { merged, merging } = state
        if merging.0 == currentValue.0 && (hexToU32 merging.2) + 1 == (hexToU32 currentValue.1) then
            {
                merged,
                merging: (merging.0, merging.1, currentValue.2),
            }
        else
            {
                merged: List.append merged merging,
                merging: currentValue,
            }
    headRes = List.first optimizedRanges
    tail = List.dropFirst optimizedRanges 1
    res =
        when headRes is
            Err _ -> crash "Something went wrong while parsing the input."
            Ok head -> List.walk tail { merged: [], merging: head } op
    List.append res.merged res.merging

# Ranges grouped by the values of their property
groupedRanges : Dict Str (List (Str, Str))
groupedRanges =
    accumulators : Dict Str (List (Str, Str))
    accumulators = Dict.empty {}
    mergedRanges
    |> List.walk accumulators \s, range ->
        Dict.update s range.0 \value ->
            when value is
                Present lst -> Present (List.append lst (range.1, range.2))
                Missing -> Present (List.single (range.1, range.2))

testsStr : Str
testsStr =
    rangeToTestStr = \(start, end) ->
        if start == end then
            "cp == $(start)"
        else
            "($(start) <= cp && cp <= $(end))"
    groupedRanges
    |> Dict.map \_, lst ->
        (List.map lst rangeToTestStr)
        |> Str.joinWith " || "
    |> Dict.map \eawp, test ->
        "if $(test) then ($(eawp))"
    |> Dict.values
    |> Str.joinWith " else "
    |> Str.concat " else N"
